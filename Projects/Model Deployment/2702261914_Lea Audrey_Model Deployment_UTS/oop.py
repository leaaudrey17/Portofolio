# -*- coding: utf-8 -*-
"""OOP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mgul60ghxCBkWfghwUA6Tnt-ZzmPL8Iw
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix

class DataLoader:
    def __init__(self, path):
        self.path = path
        self.df = None

    def load(self):
        self.df = pd.read_csv(self.path)
        return self.df

class DataCleaner:
    def __init__(self, df):
        self.df = df.copy()

    def clean(self):
        self.df.drop('Booking_ID', axis=1, inplace=True)
        self.df['type_of_meal_plan'] = self.df['type_of_meal_plan'].fillna(self.df['type_of_meal_plan'].mode()[0])
        self.df['avg_price_per_room'] = self.df['avg_price_per_room'].fillna(self.df['avg_price_per_room'].median())
        self.df['required_car_parking_space'] = self.df['required_car_parking_space'].fillna(0).astype(int)
        return self.df

class FeatureEngineer:
    def __init__(self, df):
        self.df = df.copy()
        self.scaler = StandardScaler()

    def encode(self):
        one_hot_cols = ['type_of_meal_plan', 'room_type_reserved', 'market_segment_type']
        dummies = pd.get_dummies(self.df[one_hot_cols], prefix=one_hot_cols)
        self.df.drop(columns=one_hot_cols, inplace=True)
        self.df = pd.concat([self.df, dummies], axis=1)
        self.df['booking_status'] = self.df['booking_status'].map({'Not_Canceled': 0, 'Canceled': 1})
        self.df['arrival_year'] = self.df['arrival_year'].map({2017: 0, 2018: 1})
        return self.df

    def handle_outliers_and_scale(self):
        numerical_cols = ['no_of_adults', 'no_of_children', 'no_of_weekend_nights', 'no_of_week_nights',
                          'lead_time', 'avg_price_per_room', 'no_of_previous_cancellations',
                          'no_of_previous_bookings_not_canceled', 'no_of_special_requests', 'arrival_year']
        Q1 = self.df[numerical_cols].quantile(0.25)
        Q3 = self.df[numerical_cols].quantile(0.75)
        IQR = Q3 - Q1
        lower = Q1 - 1.5 * IQR
        upper = Q3 + 1.5 * IQR
        self.df[numerical_cols] = self.df[numerical_cols].apply(lambda x: np.where(x < lower[x.name], lower[x.name], x))
        self.df[numerical_cols] = self.df[numerical_cols].apply(lambda x: np.where(x > upper[x.name], upper[x.name], x))
        self.df[numerical_cols] = self.scaler.fit_transform(self.df[numerical_cols])
        return self.df

import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix

class ModelTrainer:
    def __init__(self, X, y):
        self.X = X
        self.y = y
        self.models = {}

    def split_data(self, test_size=0.2, random_state=42):
        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(self.X, self.y, test_size=test_size, random_state=random_state)

    def train_xgboost(self):
        # Best hyperparameters found from GridSearchCV
        best_params = {
            'colsample_bytree': 0.7,
            'learning_rate': 0.1,
            'max_depth': 10,
            'n_estimators': 300,
            'subsample': 1.0
        }

        # Initialize the XGBoost model with the best parameters
        xgb_model = xgb.XGBClassifier(
            colsample_bytree=best_params['colsample_bytree'],
            learning_rate=best_params['learning_rate'],
            max_depth=best_params['max_depth'],
            n_estimators=best_params['n_estimators'],
            subsample=best_params['subsample'],
            random_state=42
        )

        # Train the model
        xgb_model.fit(self.X_train, self.y_train)

        # Store the model
        self.models['xgboost'] = xgb_model

        # Predict using the trained model
        y_pred_xgb = xgb_model.predict(self.X_test)

        return xgb_model

from sklearn.metrics import confusion_matrix, classification_report

class ModelEvaluator:
    def __init__(self, model, X_test, y_test):
        self.model = model
        self.X_test = X_test
        self.y_test = y_test

    def evaluate(self):
        y_pred = self.model.predict(self.X_test)

        print("Confusion Matrix:")
        print(confusion_matrix(self.y_test, y_pred))

        print("\nClassification Report:")
        print(classification_report(self.y_test, y_pred))

if __name__ == '__main__':
    # Load data
    loader = DataLoader('Dataset_B_hotel.csv')
    df = loader.load()

    # Clean data
    cleaner = DataCleaner(df)
    df_clean = cleaner.clean()

    # Feature engineering
    fe = FeatureEngineer(df_clean)
    df_encoded = fe.encode()
    df_final = fe.handle_outliers_and_scale()

    # Split X and y
    X = df_final.drop('booking_status', axis=1)
    y = df_final['booking_status']

    # Train models
    trainer = ModelTrainer(X, y)
    trainer.split_data()

    # Train XGBoost model
    best_xgb = trainer.train_xgboost()

    # Evaluate models
    evaluator_xgb = ModelEvaluator(best_xgb, trainer.X_test, trainer.y_test)
    evaluator_xgb.evaluate()